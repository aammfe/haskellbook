<h6 align="center">Haskell Programming</h6>
<p align="center">
  <img src="https://wiki.haskell.org/wikistatic/haskellwiki_logo.png">
</p>

##### 01 All You Need is Lambda
- [x] AllYouNeedisLambda
- [x] What is functional programming?
- [x] What is a function?
- [x] The structure of lambda terms
- [x] Beta reduction
- [x] Multiple arguments
- [x] Evaluation is simplification
- [x] Combinators
- [x] Divergence

##### 02 Hello, Haskell!
- [x] Hello,Haskell
- [x] Interacting with Haskell code
- [x] Understanding expressions
- [x] Functions
- [x] Evaluation
- [x] Infix operators
- [x] Declaring values
- [x] Arithmetic functions in Haskell
- [x] Parenthesization
- [x] Letandwhere

##### 03 Strings
- [x] Printing strings
- [x] A first look at types
- [x] Printing simple strings
- [x] Top-level versus local definitions
- [x] Types of concatenation functions
- [x] Concatenation and scoping
- [x] More list functions

##### 04 Basic datatypes
- [x] Basic Datatypes
- [x] What are types?
- [x] Anatomy of a data declaration
- [x] Numeric types
- [x] Comparing values
- [x] Go on and Bool me
- [x] Tuples
- [x] Lists

##### 05 Types
- [x] Types
- [x] What are types for?
- [x] How to read type signatures
- [x] Currying
- [x] Polymorphism
- [x] Type inference
- [x] Asserting types for declarations

##### 06 Typeclasses
- [x] Typeclasses
- [x] What are typeclasses?
- [x] Back to Bool
- [x] Eq
- [x] Writing typeclass instances
- [x] Type-defaulting typeclasses
- [x] Ord
- [x] Enum
- [x] Show
- [x] Read
- [x] Instances are dispatched by type
- [x] Gimme more operations
- [x] Typeclass inheritance, partial

##### 07 More functional patterns
- [x] Make it func-y
- [x] Arguments and parameters
- [x] Anonymous functions
- [x] Pattern matching
- [x] Case expressions
- [x] Higher-order functions
- [x] Guards
- [x] Function composition
- [x] Point freestyle
- [x] Demonstrating composition

##### 08 Recursion
- [x] Recursion
- [x] Factorial
- [x] Bottom
- [x] Fibonacci numbers
- [x] Integral division from scratch

##### 09 Lists
- [x] Lists
- [x] The list data type
- [x] Pattern matching on lists
- [x] List’s syntactic sugar
- [x] Using ranges to construct lists
- [x] Extracting portions of lists
- [x] List comprehensions
- [x] Spines and nonstrict evaluation
- [x] Transforming lists of values
- [x] Filtering lists of values
- [x] Zipping lists

##### 10 Folding lists
- [x] Folds
- [x] Bringing you into the fold
- [x] Recursive patterns
- [x] Fold right
- [x] Fold left
- [x] How to write fold functions
- [x] Folding and evaluation
- [x] Scans

##### 11 Algebraic datatypes
- [x] Algebraic datatypes
- [x] Data declarations review
- [x] Data and type constuctors
- [x] Type constructors and kinds
- [x] Data constructors and values
- [x] What's a type and what's data?
- [x] Data constructor arities
- [x] What makes these datatypes algebriac
- [x] newtype
- [x] Sum types
- [x] Product types
- [x] Normal form
- [x] Constructing and deconstructing values
- [x] Function type is exponential
- [x] Higher-kinded datatypes
- [x] Lists are polymorphic
- [x] Binary Tree

##### 12 Signaling adversity
- [x] Signaling adversity
- [x] How I learned to stop worrying and love Nothing
- [x] Bleating either
- [x] Kinds, a thousand stars in your types

##### 13 Building projects
- [x] Modules
- [x] Making packages with Stack
- [x] Working with a basic project
- [x] Making our project a library
- [x] Module exports
- [x] More on importing modules
- [x] Making our program interactive
- [x] do syntax and IO
- [x] Hangman game
- [x] Step One: Importing modules
- [x] Step Two: Generating a word list
- [x] Step Three: Making a puzzle
- [x] Adding a newtype

##### 14 Testing
- [ ] Testing
- [ ] A quick tour of testing for the uninitiated
- [ ] Conventional testing
- [ ] Enter QuickCheck
- [ ] Morse code
- [ ] Kicking around QuickCheck
 
##### 15 Monoid, Semigroup
- [ ] Monoids and semigroups
- [ ] What we talk about when we talk about algebras
- [ ] Monoid
- [ ] How Monoid is defined in Haskell
- [ ] Examples of using Monoid
- [ ] Why bother?
- [ ] Laws
- [ ] Different instance, same representation
- [ ] Reusing algebras by asking for algebras
- [ ] Madness
- [ ] Better living through QuickCheck
- [ ] Semigroup

##### 16 Functor
- [ ] Functor
- [ ] What's a functor?
- [ ] There's a whole lot of fmap going round
- [ ] Let's talk about ⨍, baby
- [ ] Functor Laws
- [ ] The Good, the Bad, and the Ugly
- [ ] Commonly used functors
- [ ] Transforming the unapplied type argument
- [ ] QuickChecking Functor instances
- [ ] Exercises: Instances of Func
- [ ] Ignoring possibilities
- [ ] A somewhat surprising functor
- [ ] More structure, more functors
- [ ] IO Functor
- [ ] What if we want to do something different?
- [ ] Functors are unique to a datatype

##### 17 Applicitive
- [ ] Applicative
- [ ] Defining Applicative
- [ ] Functor vs. Applicative
- [ ] Applicative functors are monoidal functors
- [ ] Applicative in use
- [ ] Applicative laws
- [ ] You knew this was coming
- [ ] ZipList Monoid

##### 18 Monad
- [ ] Monad
- [ ] Sorry - Monad is not a burrito
- [ ] Do syntax and monads
- [ ] Examples of Monad use
- [ ] Monad laws
- [ ] Application and composition

##### 19 Applying structure
- [ ] Applied structure
- [ ] Monoid
- [ ] Functor
- [ ] Applicative
- [ ] Monad
- [ ] An end-to-end example: URL shortener
- [ ] That's a wrap!

##### 20 Foldable
- [ ] Foldable
- [ ] The Foldable class
- [ ] Revenge of the monoids
- [ ] Demonstrating Foldable instances
- [ ] Some basic derived operations


##### 21 Traversable
##### 22 Reader
##### 23 State
##### 24 Parser combinators
##### 25 Composing types
##### 26 Monad transformers
##### 27 Non-strictness
##### 28 Basic libraries
##### 29 IO
##### 30 When things go wrong
##### 31 Final project