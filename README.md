<h6 align="center">Haskell Programming</h6>
<p align="center">
  <img src="https://wiki.haskell.org/wikistatic/haskellwiki_logo.png">
</p>

##### [01 All You Need is Lambda](https://github.com/evturn/haskell-programming/tree/master/01)
- [x] AllYouNeedisLambda
- [x] [What is functional programming?](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#functional-programming-1)
- [x] [What is a function?](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#functions-2)
- [x] [The structure of lambda terms](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#lambda-terms-1)
- [x] [Beta reduction](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#beta-reduction-1)
- [x] [Multiple arguments](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#multiple-arguments)
- [x] Evaluation is simplification
- [x] [Combinators](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#combinators)
- [x] [Divergence](https://github.com/evturn/haskell-programming/blob/master/01/notes.md#divergence)

##### [02 Hello, Haskell!](https://github.com/evturn/haskell-programming/tree/master/02)
- [x] Hello,Haskell
- [x] Interacting with Haskell code
- [x] [Understanding expressions](https://github.com/evturn/haskell-programming/blob/master/02/notes.md#expressions)
- [x] [Functions](https://github.com/evturn/haskell-programming/blob/master/02/notes.md#functions)
- [x] Evaluation
- [x] Infix operators
- [x] Declaring values
- [x] [Arithmetic functions in Haskell](https://github.com/evturn/haskell-programming/blob/master/02/notes.md#arithmetic-functions)
- [x] Parenthesization
- [x] [Letandwhere](https://github.com/evturn/haskell-programming/blob/master/02/notes.md#let-and-where)

##### [03 Strings](https://github.com/evturn/haskell-programming/tree/master/03)
- [x] Printing strings
- [x] A first look at types
- [x] Printing simple strings
- [x] Top-level versus local definitions
- [x] Types of concatenation functions
- [x] Concatenation and scoping
- [x] More list functions

##### [04 Basic datatypes](https://github.com/evturn/haskell-programming/tree/master/04)
- [x] Basic Datatypes
- [x] [What are types?](https://github.com/evturn/haskell-programming/blob/master/04/notes.md#types)
- [x] [Anatomy of a data declaration](https://github.com/evturn/haskell-programming/blob/master/04/notes.md#data-constructors)
- [x] Numeric types
- [x] Comparing values
- [x] Go on and Bool me
- [x] [Tuples](https://github.com/evturn/haskell-programming/blob/master/04/notes.md#tuple)
- [x] Lists

##### [05 Types](https://github.com/evturn/haskell-programming/tree/master/05)
- [x] Types
- [x] What are types for?
- [x] How to read type signatures
- [x] Currying
- [x] Polymorphism
- [x] Type inference
- [x] Asserting types for declarations

##### [06 Typeclasses](https://github.com/evturn/haskell-programming/tree/master/06)
- [x] Typeclasses
- [x] What are typeclasses?
- [x] Back to Bool
- [x] Eq
- [x] Writing typeclass instances
- [x] Type-defaulting typeclasses
- [x] Ord
- [x] Enum
- [x] Show
- [x] Read
- [x] [Instances are dispatched by type](https://github.com/evturn/haskell-programming/blob/master/06/notes.md#instances-are-dispatched-by-type)
- [x] Gimme more operations
- [x] Typeclass inheritance, partial

##### [07 More functional patterns](https://github.com/evturn/haskell-programming/tree/master/07)
- [x] Make it func-y
- [x] Arguments and parameters
- [x] Anonymous functions
- [x] Pattern matching
- [x] Case expressions
- [x] Higher-order functions
- [x] Guards
- [x] Function composition
- [x] Point freestyle
- [x] Demonstrating composition

##### [08 Recursion](https://github.com/evturn/haskell-programming/tree/master/08)
- [x] Recursion
- [x] Factorial
- [x] Bottom
- [x] Fibonacci numbers
- [x] Integral division from scratch

##### [09 Lists](https://github.com/evturn/haskell-programming/tree/master/09)
- [x] Lists
- [x] The list data type
- [x] Pattern matching on lists
- [x] List’s syntactic sugar
- [x] Using ranges to construct lists
- [x] Extracting portions of lists
- [x] List comprehensions
- [x] Spines and nonstrict evaluation
- [x] Transforming lists of values
- [x] Filtering lists of values
- [x] Zipping lists

##### [10 Folding lists](https://github.com/evturn/haskell-programming/tree/master/10)
- [x] Folds
- [x] Bringing you into the fold
- [x] Recursive patterns
- [x] Fold right
- [x] Fold left
- [x] How to write fold functions
- [x] Folding and evaluation
- [x] Scans

##### [11 Algebraic datatypes](https://github.com/evturn/haskell-programming/tree/master/11)
- [x] Algebraic datatypes
- [x] Data declarations review
- [x] Data and type constuctors
- [x] Type constructors and kinds
- [x] Data constructors and values
- [x] What's a type and what's data?
- [x] Data constructor arities
- [x] What makes these datatypes algebriac
- [x] newtype
- [x] Sum types
- [x] Product types
- [x] Normal form
- [x] Constructing and deconstructing values
- [x] Function type is exponential
- [x] Higher-kinded datatypes
- [x] Lists are polymorphic
- [x] Binary Tree

##### [12 Signaling adversity](https://github.com/evturn/haskell-programming/tree/master/12)
- [x] Signaling adversity
- [x] How I learned to stop worrying and love Nothing
- [x] Bleating either
- [x] Kinds, a thousand stars in your types

##### [13 Building projects](https://github.com/evturn/haskell-programming/tree/master/13)
- [x] Modules
- [x] Making packages with Stack
- [x] Working with a basic project
- [x] Making our project a library
- [x] Module exports
- [x] More on importing modules
- [x] Making our program interactive
- [x] do syntax and IO
- [x] [Hangman game](https://github.com/evturn/haskell-programming/tree/master/13/hangman)
- [x] Step One: Importing modules
- [x] Step Two: Generating a word list
- [x] Step Three: Making a puzzle
- [x] Adding a newtype

##### [14 Testing](https://github.com/evturn/haskell-programming/tree/master/14)
- [x] Testing
- [x] A quick tour of testing for the uninitiated
- [x] Conventional testing
- [x] Enter QuickCheck
- [x] [Morse code](https://github.com/evturn/haskell-programming/tree/master/14/morse)
- [x] Kicking around QuickCheck
 
##### 15 Monoid, Semigroup
- [x] Monoids and semigroups
- [x] What we talk about when we talk about algebras
- [x] Monoid
- [x] How Monoid is defined in Haskell
- [x] Examples of using Monoid
- [x] Why Integer doesn't have a Monoid
- [x] Why bother?
- [x] Laws
- [x] Different instance, same representation
- [x] Reusing algebras by asking for algebras
- [x] Madness
- [x] Better living through QuickCheck
- [x] Semigroup

##### 16 Functor
- [x] Functor
- [x] What's a functor?
- [x] There's a whole lot of fmap going round
- [x] Let's talk about ⨍, baby
- [x] Functor Laws
- [x] The Good, the Bad, and the Ugly
- [x] Commonly used functors
- [x] Transforming the unapplied type argument
- [ ] QuickChecking Functor instances
- [ ] Exercises: Instances of Func
- [ ] Ignoring possibilities
- [ ] A somewhat surprising functor
- [ ] More structure, more functors
- [ ] IO Functor
- [ ] What if we want to do something different?
- [ ] Functors are unique to a datatype

##### 17 Applicitive
- [ ] Applicative
- [ ] Defining Applicative
- [ ] Functor vs. Applicative
- [ ] Applicative functors are monoidal functors
- [ ] Applicative in use
- [ ] Applicative laws
- [ ] You knew this was coming
- [ ] ZipList Monoid

##### 18 Monad
- [ ] Monad
- [ ] Sorry - Monad is not a burrito
- [ ] Do syntax and monads
- [ ] Examples of Monad use
- [ ] Monad laws
- [ ] Application and composition

##### 19 Applying structure
- [ ] Applied structure
- [ ] Monoid
- [ ] Functor
- [ ] Applicative
- [ ] Monad
- [ ] An end-to-end example: URL shortener
- [ ] That's a wrap!

##### 20 Foldable
- [ ] Foldable
- [ ] The Foldable class
- [ ] Revenge of the monoids
- [ ] Demonstrating Foldable instances
- [ ] Some basic derived operations

##### 21 Traversable
- [ ] The Traversable
- [ ] The Traversable typeclass definition
- [ ] sequenceA
- [ ] traverse
- [ ] So, what's traversable for?
- [ ] Morse code revisited
- [ ] Axing tedious code
- [ ] Do all the things
- [ ] Traversable instances
- [ ] Traversable Laws
- [ ] Quality Control

##### 22 Reader
- [ ] Reader
- [ ] A new beginning
- [ ] This is Reader
- [ ] Breaking down the Functor of functions
- [ ] But uh, Reader?
- [ ] Functions have an Applicative too
- [ ] The Monad of functions
- [ ] Reader Monad by itself is kinda boring
- [ ] You can change what comes below, but not above
- [ ] You tn to see ReaderT, not Reader

##### 23 State
##### 24 Parser combinators
##### 25 Composing types
##### 26 Monad transformers
##### 27 Non-strictness
##### 28 Basic libraries
##### 29 IO
##### 30 When things go wrong
##### 31 Final project